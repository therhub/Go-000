学习笔记

1）微服务架构（BFF、Service、Admin、Job、Task 分模块）
将单体业务拆分成不同子服务
BFF: 负责组装数据
Service:服务实现
Admin: 代码管理
Job: 存放事务

2）API 设计（包括 API 定义、错误码规范、Error 的使用）
API设计: 定义公共的错误码
定义顶层结构, [code, message ,data]
Error返回message

3）gRPC 的使用
gRpc: 可以用pb文件定义接口，清晰可控，兼容性好，不易出错，还性能高，对越项目的接口可以采用pb文件，清晰可控，而且开发快，跨语言，可以解决这个问题。
4）Go 项目工程化（项目结构、DI、代码分层、ORM 框架）
5）并发的使用（errgroup 的并行链路请求
并发错误处理: 错误只处理一次，而且是最上层处理，但底层代码出错时，使用errgroup向上抛出，不会突然某个地方错误处理了，某个地方又没有。

6）微服务中间件的使用（ELK、Opentracing、Prometheus、Kafka）
现有项目因为第三方API的速率限制，削峰填谷，而且页面上需要不阻塞，可操作，所以使用kafka队列，消息不易丢失，而且持久化了一段时间的消息，只要写到kafka里面，消息就不会丢失，不包括客户端自己消费丢失的情况。消息写入，顺序的磁盘写再加上pagecache的加成，10万条消息，iowait几乎为0。
ELK，用于日志的收集，因为ELK无人管理，暂且搁置。
Prometheus: 还未使用

7）缓存的使用优化（一致性处理、Pipeline 优化
缓存：加速网站访问速度，因为redis和mysql两个地方都要存储数据，所有造成了分布式的数据处理，现在的业务情况是：redis可丢失，mysql保证原子性的写入就可以了。
优化: redis缓存使用pipeline管道减少请求，go使用管道chanel使得多个goroutine可以通信。

毕业总述：
系统框架设计原则需要考：，不依赖具体每个节点，而是改为依赖中间件，比如Kafka、redis、canal+mysql binlog订阅；或者无状态的服务，比如gRpc负载均衡器、etcd注册与服务发现
单个服务设计原则需要考虑：1、是否保证了完整的链路，包括错误传递、超时传递；2、各个层次的依赖是否是强依赖关系，比如使用wire、interface来解耦各个模块
3、考虑系统配置和参数使用注入形式，实现控制反转
go底层实现：1、map 拉链法+key哈希；2、channel 发送队列+接收队列+CSP模型；3、GPM调度 全局队列+IO多路复用/阻塞调用 ;4:go垃圾回收-三色标记法：标记清除算法+STW+混合写屏障
消息队列kafka：解耦调用，弱一致性数据可以实现流量的削峰限流